// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             v5.29.3
// source: docker/v1/docker.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationDockerServiceFindContainerByName = "/api.docker.v1.DockerService/FindContainerByName"
const OperationDockerServiceFindImageByName = "/api.docker.v1.DockerService/FindImageByName"
const OperationDockerServiceGetContainerLastLogs = "/api.docker.v1.DockerService/GetContainerLastLogs"
const OperationDockerServiceGetContainerStopTime = "/api.docker.v1.DockerService/GetContainerStopTime"
const OperationDockerServiceImportAndTagImage = "/api.docker.v1.DockerService/ImportAndTagImage"
const OperationDockerServiceRunAndStartContainer = "/api.docker.v1.DockerService/RunAndStartContainer"
const OperationDockerServiceRunAndStartContainerWithPort = "/api.docker.v1.DockerService/RunAndStartContainerWithPort"
const OperationDockerServiceRunContainer = "/api.docker.v1.DockerService/RunContainer"
const OperationDockerServiceStopContainer = "/api.docker.v1.DockerService/StopContainer"
const OperationDockerServiceStopContainerByName = "/api.docker.v1.DockerService/StopContainerByName"

type DockerServiceHTTPServer interface {
	// FindContainerByName 根据容器名查找容器
	FindContainerByName(context.Context, *FindContainerByNameRequest) (*FindContainerByNameReply, error)
	// FindImageByName 查找指定名称的镜像
	FindImageByName(context.Context, *FindImageByNameRequest) (*FindImageByNameReply, error)
	// GetContainerLastLogs 获取指定容器的最后若干行日志
	GetContainerLastLogs(context.Context, *GetContainerLastLogsRequest) (*GetContainerLastLogsReply, error)
	// GetContainerStopTime 获取容器的停止时间戳
	GetContainerStopTime(context.Context, *GetContainerStopTimeRequest) (*GetContainerStopTimeReply, error)
	// ImportAndTagImage 导入并标记镜像
	ImportAndTagImage(context.Context, *ImportAndTagImageRequest) (*ImportAndTagImageReply, error)
	// RunAndStartContainer 运行并启动容器，返回容器信息
	RunAndStartContainer(context.Context, *RunAndStartContainerRequest) (*RunAndStartContainerReply, error)
	// RunAndStartContainerWithPort 运行并启动带端口映射的容器
	RunAndStartContainerWithPort(context.Context, *RunAndStartContainerWithPortRequest) (*RunAndStartContainerWithPortReply, error)
	// RunContainer 通过镜像和自定义参数运行一个容器
	RunContainer(context.Context, *RunContainerRequest) (*RunContainerReply, error)
	// StopContainer 停止容器
	StopContainer(context.Context, *StopContainerRequest) (*StopContainerReply, error)
	// StopContainerByName 通过名称停止容器
	StopContainerByName(context.Context, *StopContainerByNameRequest) (*StopContainerByNameReply, error)
}

func RegisterDockerServiceHTTPServer(s *http.Server, srv DockerServiceHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/docker/container/{container_name}", _DockerService_FindContainerByName0_HTTP_Handler(srv))
	r.POST("/v1/docker/container/run", _DockerService_RunContainer0_HTTP_Handler(srv))
	r.POST("/v1/docker/container/run_start", _DockerService_RunAndStartContainer0_HTTP_Handler(srv))
	r.POST("/v1/docker/container/run_start_port", _DockerService_RunAndStartContainerWithPort0_HTTP_Handler(srv))
	r.GET("/v1/docker/container/{container_id}/logs", _DockerService_GetContainerLastLogs0_HTTP_Handler(srv))
	r.POST("/v1/docker/container/{container_id}/stop", _DockerService_StopContainer0_HTTP_Handler(srv))
	r.POST("/v1/docker/container/name/{container_name}/stop", _DockerService_StopContainerByName0_HTTP_Handler(srv))
	r.GET("/v1/docker/container/{container_id}/stop_time", _DockerService_GetContainerStopTime0_HTTP_Handler(srv))
	r.GET("/v1/docker/image/{image_name}", _DockerService_FindImageByName0_HTTP_Handler(srv))
	r.POST("/v1/docker/image/import", _DockerService_ImportAndTagImage0_HTTP_Handler(srv))
}

func _DockerService_FindContainerByName0_HTTP_Handler(srv DockerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in FindContainerByNameRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDockerServiceFindContainerByName)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.FindContainerByName(ctx, req.(*FindContainerByNameRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FindContainerByNameReply)
		return ctx.Result(200, reply)
	}
}

func _DockerService_RunContainer0_HTTP_Handler(srv DockerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RunContainerRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDockerServiceRunContainer)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RunContainer(ctx, req.(*RunContainerRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RunContainerReply)
		return ctx.Result(200, reply)
	}
}

func _DockerService_RunAndStartContainer0_HTTP_Handler(srv DockerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RunAndStartContainerRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDockerServiceRunAndStartContainer)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RunAndStartContainer(ctx, req.(*RunAndStartContainerRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RunAndStartContainerReply)
		return ctx.Result(200, reply)
	}
}

func _DockerService_RunAndStartContainerWithPort0_HTTP_Handler(srv DockerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RunAndStartContainerWithPortRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDockerServiceRunAndStartContainerWithPort)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RunAndStartContainerWithPort(ctx, req.(*RunAndStartContainerWithPortRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RunAndStartContainerWithPortReply)
		return ctx.Result(200, reply)
	}
}

func _DockerService_GetContainerLastLogs0_HTTP_Handler(srv DockerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetContainerLastLogsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDockerServiceGetContainerLastLogs)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetContainerLastLogs(ctx, req.(*GetContainerLastLogsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetContainerLastLogsReply)
		return ctx.Result(200, reply)
	}
}

func _DockerService_StopContainer0_HTTP_Handler(srv DockerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in StopContainerRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDockerServiceStopContainer)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.StopContainer(ctx, req.(*StopContainerRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*StopContainerReply)
		return ctx.Result(200, reply)
	}
}

func _DockerService_StopContainerByName0_HTTP_Handler(srv DockerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in StopContainerByNameRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDockerServiceStopContainerByName)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.StopContainerByName(ctx, req.(*StopContainerByNameRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*StopContainerByNameReply)
		return ctx.Result(200, reply)
	}
}

func _DockerService_GetContainerStopTime0_HTTP_Handler(srv DockerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetContainerStopTimeRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDockerServiceGetContainerStopTime)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetContainerStopTime(ctx, req.(*GetContainerStopTimeRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetContainerStopTimeReply)
		return ctx.Result(200, reply)
	}
}

func _DockerService_FindImageByName0_HTTP_Handler(srv DockerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in FindImageByNameRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDockerServiceFindImageByName)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.FindImageByName(ctx, req.(*FindImageByNameRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FindImageByNameReply)
		return ctx.Result(200, reply)
	}
}

func _DockerService_ImportAndTagImage0_HTTP_Handler(srv DockerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ImportAndTagImageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDockerServiceImportAndTagImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ImportAndTagImage(ctx, req.(*ImportAndTagImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ImportAndTagImageReply)
		return ctx.Result(200, reply)
	}
}

type DockerServiceHTTPClient interface {
	FindContainerByName(ctx context.Context, req *FindContainerByNameRequest, opts ...http.CallOption) (rsp *FindContainerByNameReply, err error)
	FindImageByName(ctx context.Context, req *FindImageByNameRequest, opts ...http.CallOption) (rsp *FindImageByNameReply, err error)
	GetContainerLastLogs(ctx context.Context, req *GetContainerLastLogsRequest, opts ...http.CallOption) (rsp *GetContainerLastLogsReply, err error)
	GetContainerStopTime(ctx context.Context, req *GetContainerStopTimeRequest, opts ...http.CallOption) (rsp *GetContainerStopTimeReply, err error)
	ImportAndTagImage(ctx context.Context, req *ImportAndTagImageRequest, opts ...http.CallOption) (rsp *ImportAndTagImageReply, err error)
	RunAndStartContainer(ctx context.Context, req *RunAndStartContainerRequest, opts ...http.CallOption) (rsp *RunAndStartContainerReply, err error)
	RunAndStartContainerWithPort(ctx context.Context, req *RunAndStartContainerWithPortRequest, opts ...http.CallOption) (rsp *RunAndStartContainerWithPortReply, err error)
	RunContainer(ctx context.Context, req *RunContainerRequest, opts ...http.CallOption) (rsp *RunContainerReply, err error)
	StopContainer(ctx context.Context, req *StopContainerRequest, opts ...http.CallOption) (rsp *StopContainerReply, err error)
	StopContainerByName(ctx context.Context, req *StopContainerByNameRequest, opts ...http.CallOption) (rsp *StopContainerByNameReply, err error)
}

type DockerServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewDockerServiceHTTPClient(client *http.Client) DockerServiceHTTPClient {
	return &DockerServiceHTTPClientImpl{client}
}

func (c *DockerServiceHTTPClientImpl) FindContainerByName(ctx context.Context, in *FindContainerByNameRequest, opts ...http.CallOption) (*FindContainerByNameReply, error) {
	var out FindContainerByNameReply
	pattern := "/v1/docker/container/{container_name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationDockerServiceFindContainerByName))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DockerServiceHTTPClientImpl) FindImageByName(ctx context.Context, in *FindImageByNameRequest, opts ...http.CallOption) (*FindImageByNameReply, error) {
	var out FindImageByNameReply
	pattern := "/v1/docker/image/{image_name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationDockerServiceFindImageByName))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DockerServiceHTTPClientImpl) GetContainerLastLogs(ctx context.Context, in *GetContainerLastLogsRequest, opts ...http.CallOption) (*GetContainerLastLogsReply, error) {
	var out GetContainerLastLogsReply
	pattern := "/v1/docker/container/{container_id}/logs"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationDockerServiceGetContainerLastLogs))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DockerServiceHTTPClientImpl) GetContainerStopTime(ctx context.Context, in *GetContainerStopTimeRequest, opts ...http.CallOption) (*GetContainerStopTimeReply, error) {
	var out GetContainerStopTimeReply
	pattern := "/v1/docker/container/{container_id}/stop_time"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationDockerServiceGetContainerStopTime))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DockerServiceHTTPClientImpl) ImportAndTagImage(ctx context.Context, in *ImportAndTagImageRequest, opts ...http.CallOption) (*ImportAndTagImageReply, error) {
	var out ImportAndTagImageReply
	pattern := "/v1/docker/image/import"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDockerServiceImportAndTagImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DockerServiceHTTPClientImpl) RunAndStartContainer(ctx context.Context, in *RunAndStartContainerRequest, opts ...http.CallOption) (*RunAndStartContainerReply, error) {
	var out RunAndStartContainerReply
	pattern := "/v1/docker/container/run_start"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDockerServiceRunAndStartContainer))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DockerServiceHTTPClientImpl) RunAndStartContainerWithPort(ctx context.Context, in *RunAndStartContainerWithPortRequest, opts ...http.CallOption) (*RunAndStartContainerWithPortReply, error) {
	var out RunAndStartContainerWithPortReply
	pattern := "/v1/docker/container/run_start_port"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDockerServiceRunAndStartContainerWithPort))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DockerServiceHTTPClientImpl) RunContainer(ctx context.Context, in *RunContainerRequest, opts ...http.CallOption) (*RunContainerReply, error) {
	var out RunContainerReply
	pattern := "/v1/docker/container/run"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDockerServiceRunContainer))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DockerServiceHTTPClientImpl) StopContainer(ctx context.Context, in *StopContainerRequest, opts ...http.CallOption) (*StopContainerReply, error) {
	var out StopContainerReply
	pattern := "/v1/docker/container/{container_id}/stop"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDockerServiceStopContainer))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DockerServiceHTTPClientImpl) StopContainerByName(ctx context.Context, in *StopContainerByNameRequest, opts ...http.CallOption) (*StopContainerByNameReply, error) {
	var out StopContainerByNameReply
	pattern := "/v1/docker/container/name/{container_name}/stop"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDockerServiceStopContainerByName))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
